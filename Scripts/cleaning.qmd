---
title: "Preprocessing"
format: html
---

# Setup

```{r}
library(tidyverse)
library(jsonlite)
library(data.table)
library(dplyr)
library(tidyr)
library(here)
```


# Read in example files:


## FIRST METHOD
```{r}
ex_file <- jsonlite::fromJSON(here::here("/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/preprocessed/first_round_json/AaPeO-0105-1.json"))

test_df <- ex_file %>% 
  as.data.frame()


#OBS/conclusion: this only works for some of the json files, depending on the format

```


## SECOND METHOD
```{r}
#read in file which has different kind of reactions to see how that looks 
ex_file_diff_reac <- jsonlite::fromJSON(here::here("/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/preprocessed/first_round_json/AaPeO-0705-1.json"))

#can print the type of object: list
#class(ex_file_diff_reac)
#can print the content of the whole object
#str(ex_file_diff_reac)


#applies the function as.data.frame.list (making list to dataframe i.e each element of the list becomes a column in the resulting data frame.) to each element of the list ex_file_diff_reac using lapply function and stores the result in a new list called r1.
r1 <- lapply(ex_file_diff_reac, as.data.frame.list)
# takes the list of data frames r1, combines them row-wise into a single data frame using rbindlist, fill every missing value with NA, and then converts the resulting data table into a data frame using as.data.frame()
test_df_diff_reac <- rbindlist(r1, fill=TRUE) %>% 
  as.data.frame()

#OBS/conclusion: this only works for some of the json files, depending on the format
```


## THIRD METHOD
```{r}
#test to load in json without comments to see how it looks
no_com_file <- jsonlite::fromJSON(here::here("/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/preprocessed/first_round_json/AnKeP-1405-1.json"))

test_df_no_com <- no_com_file %>%
  bind_rows() %>%
  as.data.frame() %>%
  #if the column 'coments.text does not exist make a new column 'no_comments' and set value to 0
  mutate(has_comments = ifelse(!"comments.text" %in% names(.), 0, NA))


```


### Test: loading in all 3 files using the second method, renaming columns and combining into 1 df 

```{r}
library(plyr)

#for ex_file list
r2 <- lapply(ex_file, as.data.frame.list)
test_df_2 <- rbindlist(r2, fill=TRUE) %>% 
  as.data.frame()

#for no_com_file list
r3 <- lapply(no_com_file, as.data.frame.list)
test_df_3 <- rbindlist(r3, fill=TRUE) %>% 
  as.data.frame()

#rename the first 6 columns for the 3 dataframes i want to combine 
colnames(test_df_diff_reac)[1:6] <- c("Column1", "Column2", "Column3", "Column4", "Column5", "Column6")
colnames(test_df_2)[1:6] <- c("Column1", "Column2", "Column3", "Column4", "Column5", "Column6")
colnames(test_df_3)[1:6] <- c("Column1", "Column2", "Column3", "Column4", "Column5", "Column6")


#combine:
combined_df <- rbindlist(list(test_df_diff_reac, test_df_2, test_df_3), fill = TRUE, idcol=TRUE)
#fill any missing values with NA
#idcol=TRUE makes an id for each dataframe that is using when combining

#Use this approach from here on!

```


# Load in data

```{r}
#WORKS THE WAY I WANT!

#Load in the 35 files from the test_data_35_files folder:
files <- list.files(path="/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/test_data_35_files", pattern="*.json", full.names=TRUE, recursive=FALSE)

# Initialize an empty data frame to hold the combined data
combined_data_frame_35 <- NULL  
# Initialize an ID counter
id_counter <- 1

# for-loop going through each element in files
for(i in 1:length(files)) { 
  # Read in json file as list
  list <- jsonlite::fromJSON(here::here(files[i]))
  # Make a new list making everything in 'list' into dataframes
  new_list <- lapply(list, as.data.frame.list)
  # Takes the list of data frames new_list, combines them row-wise, fill with NA, and make a dataframe
  data_frame <- rbindlist(new_list, fill=TRUE) %>% 
    as.data.frame()
  # Rename the first 6 columns
  colnames(data_frame)[1:6] <- c("Column1", "Column2", "Column3", "Column4", "Column5", "Column6")
  # Add an ID column
  data_frame$ID <- id_counter
  # Increment ID counter for the next data frame
  id_counter <- id_counter + 1
  #Add file_name column
  data_frame$file_name <- files[i]
  # Combine into dataframe
  combined_data_frame_35 <- rbindlist(list(data_frame, combined_data_frame_35), fill = TRUE)
}


```



# Preprocessing based on the 'combined_data_frame_35'

```{r}
#Fixing Column5 and Column6 for the ID's where Column4 (HasMedia) == FALSE i.e. transferring reactions and counts to their correct places:

# Loop through each unique ID in the dataframe
for (id_value in unique(combined_data_frame_35$ID)) {
  # Subset the dataframe for the current ID
  subset_idx <- which(combined_data_frame_35$ID == id_value)
  subset_df <- combined_data_frame_35[subset_idx, ]
  
  # Check if the 4th cell in the 'Column4' column is FALSE
  if (subset_df[4, "Column4"] == FALSE) {
    # Save the values of the 5th cell in 'Column5' and 'Column6'
    cell_value_1 <- subset_df[5, "Column5"]
    cell_value_2 <- subset_df[5, "Column6"]
    
    # Set the original cells to NA
    subset_df[5, c("Column5", "Column6")] <- NA
    
    # Place the saved values in the 'type' and 'count' columns
    subset_df[5, "type"] <- cell_value_1
    subset_df[5, "count"] <- cell_value_2
    
    # Check if a 6th row exists and it's not NA
    if (!is.na(subset_df[6, "Column5"]) && !is.na(subset_df[6, "Column6"])) {
      # Save the values of the 6th cell in 'Column5' and 'Column6'
      cell_value_3 <- subset_df[6, "Column5"]
      cell_value_4 <- subset_df[6, "Column6"]
      
      # Set the original cells to NA
      subset_df[6, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[6, "type"] <- cell_value_3
      subset_df[6, "count"] <- cell_value_4
    }
    
    # Check if a 7th row exists and it's not NA
    if (!is.na(subset_df[7, "Column5"]) && !is.na(subset_df[7, "Column6"])) {
      # Save the values of the 7th cell in 'Column5' and 'Column6'
      cell_value_5 <- subset_df[7, "Column5"]
      cell_value_6 <- subset_df[7, "Column6"]
      
      # Set the original cells to NA
      subset_df[7, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[7, "type"] <- cell_value_5
      subset_df[7, "count"] <- cell_value_6
    }
    
    # Check if a 8th row exists and it's not NA
    if (!is.na(subset_df[8, "Column5"]) && !is.na(subset_df[8, "Column6"])) {
      # Save the values of the 8th cell in 'Column5' and 'Column6'
      cell_value_7 <- subset_df[8, "Column5"]
      cell_value_8 <- subset_df[8, "Column6"]
      
      # Set the original cells to NA
      subset_df[8, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[8, "type"] <- cell_value_7
      subset_df[8, "count"] <- cell_value_8
    }
    
    # Check if a 9th row exists and it's not NA
    if (!is.na(subset_df[9, "Column5"]) && !is.na(subset_df[9, "Column6"])) {
      # Save the values of the 9th cell in 'Column5' and 'Column6'
      cell_value_9 <- subset_df[9, "Column5"]
      cell_value_10 <- subset_df[9, "Column6"]
      
      # Set the original cells to NA
      subset_df[9, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[9, "type"] <- cell_value_9
      subset_df[9, "count"] <- cell_value_10
    }
    
    # Check if a 10th row exists and it's not NA
    if (!is.na(subset_df[10, "Column5"]) && !is.na(subset_df[10, "Column6"])) {
      # Save the values of the 10th cell in 'Column5' and 'Column6'
      cell_value_11 <- subset_df[10, "Column5"]
      cell_value_12 <- subset_df[10, "Column6"]
      
      # Set the original cells to NA
      subset_df[10, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[10, "type"] <- cell_value_11
      subset_df[10, "count"] <- cell_value_12
    }
    
    # Check if a 11th row exists and it's not NA
    if (!is.na(subset_df[11, "Column5"]) && !is.na(subset_df[11, "Column6"])) {
      # Save the values of the 11th cell in 'Column5' and 'Column6'
      cell_value_13 <- subset_df[11, "Column5"]
      cell_value_14 <- subset_df[11, "Column6"]
      
      # Set the original cells to NA
      subset_df[11, c("Column5", "Column6")] <- NA
      
      # Place the saved values in the 'type' and 'count' columns
      subset_df[11, "type"] <- cell_value_13
      subset_df[11, "count"] <- cell_value_14
    }

    # Update the original dataframe with the modified subset
    combined_data_frame_35[subset_idx, ] <- subset_df
  }
} 
```


```{r}
#Creating total_n_comments
combined_data_frame_35 <- combined_data_frame_35 %>%
  group_by(ID) %>%
  mutate(total_n_comments = sum(!is.na(id))) %>%
  ungroup()  # Ungroup the data

#creating has_comments 
combined_data_frame_35$has_comments <- 0  # Initialize the column with 0

for (i in 1:nrow(combined_data_frame_35)) {
  if (combined_data_frame_35$total_n_comments[i] < 1)
    combined_data_frame_35$has_comments[i] <- 0
  else
    combined_data_frame_35$has_comments[i] <- 1
}

#Creating n_total_reactions_post
combined_data_frame_35 <- combined_data_frame_35 %>%
  group_by(ID) %>%
  mutate(count= as.numeric(count)) %>%
  mutate(n_total_reactions_post = sum(count,na.rm=TRUE)) %>%
  ungroup()  # Ungroup the data


```



```{r}
#Make new columns to be filled
combined_data_frame_35$count_like_pos	<- NA
combined_data_frame_35$count_heart_pos <- NA	
combined_data_frame_35$count_haha_pos <- NA
combined_data_frame_35$count_care_pos <- NA
combined_data_frame_35$count_angry_pos <- NA
combined_data_frame_35$count_sad_pos <- NA
combined_data_frame_35$count_wow_pos <- NA

#fill columns based on conditions
for (id_value in unique(combined_data_frame_35$ID)) {
  # Subset the dataframe for the current ID
  subset_idx <- which(combined_data_frame_35$ID == id_value)
  subset_df <- combined_data_frame_35[subset_idx, ]
  
  # Check if the word 'like' exists in the column 'type'
  if ("like" %in% subset_df$type) {
    # Find the index of the cell containing 'like'
    like_index <- which(subset_df$type == "like")
    # Get the value to the right of the cell containing 'like'
    like_variable <- subset_df$count[like_index] 
    # Place the saved values in the first row of the count_like_pos column
    subset_df$count_like_pos[1] <- like_variable
  }
  if ("heart" %in% subset_df$type) {
    heart_index <- which(subset_df$type == "heart")
    heart_variable <- subset_df$count[heart_index] 
    subset_df$count_heart_pos[1] <- heart_variable
  }
  if ("haha" %in% subset_df$type) {
    haha_index <- which(subset_df$type == "haha")
    haha_variable <- subset_df$count[haha_index] 
    subset_df$count_haha_pos[1] <- haha_variable
  }
  if ("care" %in% subset_df$type) {
    care_index <- which(subset_df$type == "care")
    care_variable <- subset_df$count[care_index] 
    subset_df$count_care_pos[1] <- care_variable
  }
  if ("angry" %in% subset_df$type) {
    angry_index <- which(subset_df$type == "angry")
    angry_variable <- subset_df$count[angry_index] 
    subset_df$count_angry_pos[1] <- angry_variable
  }
  if ("sad" %in% subset_df$type) {
    sad_index <- which(subset_df$type == "sad")
    sad_variable <- subset_df$count[sad_index] 
    subset_df$count_sad_pos[1] <- sad_variable
  }
  if ("wow" %in% subset_df$type) {
    wow_index <- which(subset_df$type == "wow")
    wow_variable <- subset_df$count[wow_index] 
    subset_df$count_wow_pos[1] <- wow_variable
  }
  
  # Update the original dataframe with the modified subset
  combined_data_frame_35[subset_idx, ] <- subset_df
}



#make n_likes_com, n_heart_com etc. on the comments
#Make new columns to be filled
combined_data_frame_35$n_total_reactions_com <- NA
#NEED TO DO THIS

combined_data_frame_35$count_like_com	<- NA
combined_data_frame_35$count_heart_com <- NA	
combined_data_frame_35$count_haha_com <- NA
combined_data_frame_35$count_care_com <- NA
combined_data_frame_35$count_angry_com <- NA
combined_data_frame_35$count_sad_com <- NA
combined_data_frame_35$count_wow_com <- NA

#make 'reactions.type' as character
combined_data_frame_35 <- combined_data_frame_35 %>%
  mutate(reactions.types= as.character(reactions.types)) 
# first sub NULL , character(0) , list() with NAs
combined_data_frame_35$reactions.types <- sub("NULL", NA, combined_data_frame_35$reactions.types)
combined_data_frame_35$reactions.types <- sub("list()", NA, combined_data_frame_35$reactions.types)
combined_data_frame_35$reactions.types[combined_data_frame_35$reactions.types == "character(0)"] <- NA

#fill columns based on conditions:
```

```{r}
#not working
for (id_value in unique(combined_data_frame_35$ID)) {
  # Subset the dataframe for the current ID
  subset_idx <- which(combined_data_frame_35$ID == id_value)
  subset_df <- combined_data_frame_35[subset_idx, ]
  if ("like" %in% subset_df$reactions.types) {
    # Find the index of the cell containing 'like'
    like_index <- which(subset_df$reactions.types == "like")
    
    # Get the index of the value to the left of the cell containing 'like'
    left_index <- like_index - 1
    
    # Check if the left index is valid (not out of bounds)
    valid_index <- left_index > 0
    
    # Get the left variable if it is a valid index, otherwise assign NA
    left_variable <- ifelse(any(valid_index), subset_df$reactions.totalCount[left_index[valid_index]], NA)
    
    # Place the saved value in the corresponding row of count_like_com column
    subset_df$count_like_com[like_index] <- left_variable
  }
    combined_data_frame_35[subset_idx, ] <- subset_df
}
```

```{r}
combined_data_frame_35$reactions.totalCount[combined_data_frame_35$reactions.totalCount == 0] <- NA

#not working
for (id_value in unique(combined_data_frame_35$ID)) {
  # Subset the dataframe for the current ID
  subset_idx <- which(combined_data_frame_35$ID == id_value)
  subset_df <- combined_data_frame_35[subset_idx, ]
  if ("like" %in% subset_df$reactions.types) {
    # Find the index of the cell containing 'like'
    like_index <- which(subset_df$reactions.types == "like")
    
    # Get the index of the value to the left of the cell containing 'like'
    left_index <- like_index - 1
    
    # Check if the left index is valid (not out of bounds)
    valid_index <- left_index > 0
    
    # Get the left variable if it is a valid index, otherwise assign NA
    left_variable <- ifelse(any(valid_index), subset_df$reactions.totalCount[left_index], NA)
    
    # Place the saved value in the corresponding row of count_like_com column
    subset_df$count_like_com[like_index] <- left_variable
  }
  
  combined_data_frame_35[subset_idx, ] <- subset_df
}


```


```{r}
like_index
```
```{r}
left_index
```
```{r}
left_variable
```


```{r}
#make main_post variable
```



```{r}
#shorten the file_name column 
combined_data_frame_35$file_name <- sub("/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/test_data_35_files/", "" , combined_data_frame_35$file_name)

## Based on the file_name column make:

#name_abbreviation
for (row in 1:nrow(combined_data_frame_35)) {
  combined_data_frame_35$name_abbreviation[row] <- substr(combined_data_frame_35$file_name[row], 1, 4)
}

#date_data_collection
for (row in 1:nrow(combined_data_frame_35)) {
  combined_data_frame_35$date_data_collection[row] <- substr(combined_data_frame_35$file_name[row], 7, 10)
}

#offentlig_privat
for (row in 1:nrow(combined_data_frame_35)) {
  combined_data_frame_35$offentlig_privat[row] <- substr(combined_data_frame_35$file_name[row], 5,5)
}

#Week



```


Week 1: monday 0105 to 0705

Week 2: 0805 to 1405

Week 3: 1505 to 2105

Week 4: 2205 to 2805

Week 5: 2905 to 0406

Week 6: 0506 to 1106

Week 7: 1206 to 1806

Week 8: 1906 to 2506

(Week 9: 2606 to 0207)
```{r}
#Weeks

for (row in 1:nrow(combined_data_frame_35)) {
  combined_data_frame_35$week[row] <- 
    
}


```


```{r}
#make subcomment variable
```


```{r}
#what might need to be (at least partly) manually coded 

#group (treatment vs. control)
  #assigning treatment column
  #if name= AuKe, and week==1, treatment= yes
  #OR = if ''SIG FRA, ANDMELD, ..." is present in 'text', treatment= yes

#municupality
  #list of abbrivations
  #from_Ã¥rhus = c[AmBe, KuDo]
    #if combined_data_frame$pol_abbrivations == in list 

```



When the desired structure is reached:
# Loop through ALL files 
```{r}

```










##SIMONS CODE: 

# check for files not converted

Some of the html files were not converted to .json. Checking which ones here, to maybe rectify the problem.
--> Saving the filenames not converted to automatically resave them as word files (correcting weird encoding issues that happened when they were initially saved).
--> Using apple scripts to automatically open and resave these files.

## First round files
```{r}
html_first_round <- list.files(path = "/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/raw/first_round/html/") %>% #save all html filenames from first round folder in a list
  str_remove_all(".html") #remove .html ending 

json_first_round <- list.files(path = "/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/preprocessed/first_round_json/") %>% #save all json filenames from first round folder in a list
  str_remove_all(".json") #remove all .json ending

length(html_first_round[!html_first_round %in% json_first_round])
#lenght of files in html_first_round that is not in json_first_round

html_first_round[!html_first_round %in% json_first_round] %>% #if in html_first_round and not in json_first_round
  paste0(".html") %>% #write filename and extend with .html
  write.table("filenames_not_converted_first_round_ida.txt", row.names = FALSE, col.names = FALSE) #write to a table and save in wd
```


## Second Round files
```{r}
html_second_round <- list.files(path = "/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/raw/second_round/html/") %>% 
  str_remove_all(".html")

json_second_round <- list.files(path = "/Users/idahelenedencker/Desktop/STANDBY/Facebook_Field_2023-kopi/data/preprocessed/second_round_json/") %>% 
  str_remove_all(".json")

length(html_second_round[!html_second_round %in% json_second_round])

```

