two_level_model$coef
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model)
print(fixed_effects)
summary(two_level_model)
#set range
X1_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#set range
X1_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.1)
X1_range
#set range
X1_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
X1_range
min(sentiment_data$compound_roberta)
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality (1| ID), data = sentiment_data, family = binomial)
View(sentiment_data)
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
summary(two_level_model_muni)
#calculate probs for each of the 8 levels
p_SC_logits <-b0 +
rob * X1_range +
cop *0  #This is the reference group, i.e the first level of the com_guess_cer i.e. p_SC
b0 <- -0.2697# intercept
rob <- -0.4848
cop <- -1.9202
#set range
X1_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 8 levels
p_SC_logits <-b0 +
rob * X1_range +
cop *0  #This is the reference group, i.e the first level of the com_guess_cer i.e. p_SC
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * X1_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * X1_range +
cop *1
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(p_SU_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, com=X1_range)
plot.data <- gather(plot.data, key=group, value=prob, aarhus:copenhagen)
# Creating the plot and adding the first line for the p_SC predictor
plot(X1_range, aar_probs,
ylim=c(0,1),
type="l",
lwd=3,
lty=2,
col="gold",
xlab="Number of pink in sample", ylab="Prob of choosing yellow", main="Effect of Agent and their certainty")
# Add the line for the p_SU predictor
lines(X1_range, cop_probs,
type="l",
lwd=3,
lty=3,
col="turquoise2")
plot(X1_range, aar_probs,
ylim=c(0,1),
type="l",
lwd=3,
lty=2,
col="gold",
xlab="Number of pink in sample", ylab="Prob of choosing yellow", main="Effect of Agent and their certainty")
# Add the line for the p_SU predictor
lines(X1_range, cop_probs,
type="l",
lwd=3,
lty=3,
col="turquoise2")
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(a=aar_probs, b=cop_probs, X1=X1_range)
plot.data <- gather(plot.data, key=group, value=prob, a:b)
head(plot.data)
ggplot(plot.data, aes(x=X1, y=prob, color=group)) + # asking it to set the color by the variable "group" is what makes it draw three different lines
geom_line(lwd=2) +
labs(x="X1", y="P(outcome)", title="Probability of super important outcome")
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, X1=X1_range)
plot.data <- gather(plot.data, key=group, value=prob, aar:cop)
head(plot.data)
ggplot(plot.data, aes(x=X1, y=prob, color=group)) + # asking it to set the color by the variable "group" is what makes it draw three different lines
geom_line(lwd=2) +
labs(x="X1", y="P(outcome)", title="Probability of super important outcome")
# make a plot like this one: https://blogs.uoregon.edu/rclub/2016/04/05/plotting-your-logistic-regression-models/
#like i did for a previous exam
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
summary(two_level_model_muni)
b0 <- -0.2697 # intercept
rob <- -0.4848
cop <- -1.9202
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, com=compound_range)
plot.data <- gather(plot.data, key=group, value=prob, aar:cop)
head(plot.data)
ggplot(plot.data, aes(x=com, y=prob, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
View(sentiment_data)
summary(two_level_model_muni)
# make a plot like this one: https://blogs.uoregon.edu/rclub/2016/04/05/plotting-your-logistic-regression-models/
#like i did for a previous exam
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
summary(two_level_model_muni)
b0 <- -16.2807   # intercept
rob <- -0.4848
cop <- -1.9202
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, com=compound_range)
plot.data <- gather(plot.data, key=group, value=prob, aar:cop)
head(plot.data)
ggplot(plot.data, aes(x=com, y=prob, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
compound_range
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
aar_logits
cop_logits
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
cop_probs
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
#to include muni, make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
summary(two_level_model_muni)
b0 <- -16.2807   # intercept
rob <- -0.4848
cop <- -1.9202
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, com=compound_range)
plot.data <- gather(plot.data, key=group, value=probs, aar:cop)
head(plot.data)
ggplot(plot.data, aes(x=com, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
# make a plot like this one: https://blogs.uoregon.edu/rclub/2016/04/05/plotting-your-logistic-regression-models/
#like i did for a previous exam
#make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
summary(two_level_model_muni)
b0 <- -16.2807   # intercept
rob <- -0.4848
cop <- -1.9202
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
# Compute the probibilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, compound_roberta=compound_range)
plot.data <- gather(plot.data, key=group, value=probs, aar:cop)
head(plot.data)
ggplot(plot.data, aes(x=com, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
plot(compound_range, aar_probs,
ylim=c(0,1),
type="l",
lwd=3,
lty=2,
col="gold",
xlab="X1", ylab="P(outcome)", main="Probability of super important outcome")
# Add the line for people who are in the b group
lines(compound_range, cop_probs,
type="l",
lwd=3,
lty=3,
col="turquoise2")
# Your plotting code
ggplot(plot.data, aes(x=com, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
ggplot(plot.data, aes(x=compound_roberta, y=log(probs), color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Log Probability of the intervention being yes", title="Probability of intervention by municipality")
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
gplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
ggplot(plot.data, aes(x=compound_roberta, y=log(probs), color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Log Probability of the intervention being yes", title="Probability of intervention by municipality")
ggplot(plot.data, aes(x=compound_roberta, y=log(probs), color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Log Probability of the intervention being yes", title="Probability of intervention by municipality")
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
geom_line(lwd=2) +
labs(x="Compound", y="Probabulty of the intervention being yes", title="Probability of intervention by municipality")
# Your plotting code
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, lme4)
#load in data
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/Sentiment CSV files/5_types_sen.csv')
#can check number of distinct values for a column
n_distinct(sentiment_data$ID)
# preprocessing the data
#check class of every column
sapply(sentiment_data, class)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g we can't have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
offentlig_privat = as.factor(offentlig_privat),
roberta_label = as.factor(roberta_label),
name_abbreviation = as.factor(name_abbreviation)
)
#should ID be level??
#check the levels look right
sapply(sentiment_data, levels)
#can check the number of levels for a factor column
nlevels(sentiment_data$name_abbreviation)
library(ggplot2)
library(gridExtra)
# Plotting positive scores
p1 <- ggplot(sentiment_data, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
# Plotting neutral scores
p2 <- ggplot(sentiment_data, aes(x = intervention, y = neu_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "black") +
labs(title = "Neutral") +
theme_minimal()
# Plotting negative scores
p3 <- ggplot(sentiment_data, aes(x = intervention, y = neg_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "salmon", color = "black") +
labs(title = "Negative") +
theme_minimal()
# Plotting compound scores
p4 <- ggplot(sentiment_data, aes(x = intervention, y = compound_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgrey", color = "black") +
labs(title = "Compound") +
theme_minimal()
# Combining plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
#looking here we see that when the intervention is yes the comments are generally more negative (lower pos score + higher neg score + lower compound score). This is good to know before starting to model the effect of intervention. So looking at this, we expect that an intervention (intervention==yes) will entail a more negative sentiment in comments compared to no intervention (intervention == no)
#First: check level of the outcome variable
levels(sentiment_data$intervention)
#first level (here no) is encoded as 0 and the second level (here yes) is encoded as 1, estimates we are getting are **log odds of level 1** i.e. the probability of the intervention being yes
#remember that in logistic regression coefficients are a on log-oods scale = positive means increase in possibility
##log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by group
##INTERCEPT ONLY MODEL:
#Below are the commands to run an empty model, that is, a model containing no predictors,
empty_model <- glmer(intervention ~ ( 1 | ID), data=sentiment_data, family = "binomial")
summary(empty_model)
#There is substantial variability in the intercept across different levels of ID (Std.Dev. = 88.07), suggesting that the random effect of ID is important in the model.
# The intercept of -17.689 is significantly different from zero, indicating that on average, without considering the random effect, the log odds of intervention are very low. That makes sence since there are way more no-intervention posts, so the general probabilty of the post being intervention is very low
## SIMPLE LOGISTIC REGRESSION MODEL (no mixed effects):
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound_roberta,family=binomial(link='logit'),data=sentiment_data)
summary(no_mixed_model)
#no random effects: assume all data are independent from each other (not the case here)
#when the compound score increase with 1 (more positive sentiment) the log odds of the intervention being yes decreases with -0.59, i.e. more positive sentiment entails a lower probability of the intervention being yes, in accordance with what the plots above are showing. The predictor is siggnificant here.
## 2-LEVEL MODEL (Comments nested in ID):
two_level_model <- glmer(intervention ~ compound_roberta + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model)
# allowing to vary by ID
# The intercept of the fixed effects are stil negative, indicating that in increse in compund decreses the possibility of intervention. After having accounted for the fact that some of the variance in sentiment can be accounted for by ID, not 'much is left' for the model to explaing the compund by the intervention
## 3-LEVEL MODEL (comments nested in ID nested in politicians):
three_level_model <- glmer(intervention ~ compound_roberta + (1| ID/name_abbreviation), data = sentiment_data, family = binomial)
summary(three_level_model)
# Same case as with the 2-level model
## 4-LEVEL MODEL (comments nested in ID nested in politicians nested in municipality):
four_level_model <- glmer(intervention ~ compound_roberta + (1| ID/name_abbreviation/municipality), data = sentiment_data, family = binomial)
summary(four_level_model)
## NO HIERARCHY MODEL
#a model with separate random intercepts for each grouping variable without explicitly specifying the nesting. This is assuming that the grouping variables are independent of each other.
no_hier_model <- glmer(intervention ~ compound_roberta + (1| ID) + (1| name_abbreviation) + (1| municipality), data = sentiment_data, family = binomial)
summary(no_hier_model)
#maybe make a model only varying by ID, 1 only my politician, 1 only by municipality?
#compare the different models like this:
f1 <- performance::model_performance(empty_model, metrics= "common")
f2 <- performance::model_performance(no_mixed_model, metrics= "common")
f3 <- performance::model_performance(two_level_model, metrics= "common")
f4 <- performance::model_performance(three_level_model, metrics= "common")
f5 <- performance::model_performance(four_level_model, metrics= "common")
f6 <- performance::model_performance(no_hier_model, metrics= "common")
print("empty_model:")
f1
print("no_mixed_model:")
f2
print("two_level_model:")
f3
print("three_level_model:")
f4
print("four_level_model:")
f5
print("no_hier_model:")
f6
# The empty model and and the 2 level models has the lowest AIC indicating better model performance. These howver are not very useful to us. The empty model has obviously no predictors. The 2-level model
# make a plot like this one: https://blogs.uoregon.edu/rclub/2016/04/05/plotting-your-logistic-regression-models/
#like i did for a previous exam
#make a model like two_level_model with muni as predictor too
two_level_model_muni <- glmer(intervention ~ compound_roberta + municipality + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model_muni)
# check the levels
levels(sentiment_data$municipality)
#Get the coefficients from the (best) model
fixed_effects <- fixef(two_level_model_muni)
print(fixed_effects)
b0 <- -16.2807   # intercept
rob <- -0.4848
cop <- -1.9202
#set range
compound_range <- seq(from=min(sentiment_data$compound_roberta), to=max(sentiment_data$compound_roberta), by=.01)
#calculate probs for each of the 2 levels
aar_logits <-b0 +
rob * compound_range +
cop *0  #This is the reference group, i.e the first level of the muni i.e. aarhus
cop_logits <-b0 +
rob * compound_range +
cop *1
# Compute the probabilities (this is what will actually get plotted):
aar_probs<- exp(aar_logits)/(1 + exp(aar_logits))
cop_probs<- exp(cop_logits)/(1 + exp(cop_logits))
# the plot can be done in ggplot, which automatically adds legends
# first you have to get the information into a long dataframe, which is what ggplot likes :)
plot.data <- data.frame(aar=aar_probs, cop=cop_probs, compound_roberta=compound_range)
plot.data <- gather(plot.data, key=group, value=probs, aar:cop)
head(plot.data)
#ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) + # asking it to set the color by the variable "group" is what makes it draw different lines
#geom_line(lwd=2) +
#labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality")
# Your plotting code
ggplot(plot.data, aes(x=compound_roberta, y=probs, color=group)) +
geom_line(lwd=2) +
labs(x="Compound", y="Probability of the intervention being yes", title="Probability of intervention by municipality") +
# Scale the y-axis using log10 transformation
scale_y_continuous(trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x)))
#ggplot(plot.data, aes(x=compound_roberta, y=log(probs), color=group)) +
#geom_line(lwd=2) +
#labs(x="Compound", y="Log Probability of the intervention being yes", title="Probability of intervention by municipality")
#the results show any possible difference in effect for the different municipalities. Generally, the probability for the intervention being yes is low, hence the very small numbers on the y-axis. The curvature of the 2 lines resemble each other
#can do some simple plotting
plot(pos_score_roberta ~ neg_score_roberta, data = sentiment_data, main = "pos_score_roberta ~ neg_score_roberta")
#
# plotting and calculations
View(sentiment_data)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + total_n_reactions (1 | ID), data=mlmdata)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + total_n_reactions (1 | ID), data=sentiment_data)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions (1 | ID), data=sentiment_data)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions (1 | ID), data=sentiment_data)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions + (1 | ID), data=sentiment_data)
summary(model)
levels(sentiment_data$total_n_comments)
levels(sentiment_data$n_total_reactions)
levels(sentiment_data$offentlig_privat)
summary(model)
model_reactions <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions + count_like + count_haha+ count_heart+ count_care + count_sad + count_wow + count_angry + (1 | ID), data=sentiment_data)
summary(model_reactions)
# Remove rows where 'main_post' is '1'
sentiment_data_only_comments <- sentiment_data[sentiment_data$main_post != 1, ]
View(sentiment_data_only_comments)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions + (1 | ID), data=sentiment_data_only_comments)
summary(model)
model <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions + (1 | ID), data=sentiment_data)
summary(model)
model_reactions <- lmer(compound_roberta ~ municipality + offentlig_privat + total_n_comments + n_total_reactions + count_like + count_haha+ count_heart+ count_care + count_sad + count_wow + count_angry + (1 | ID), data=sentiment_data_only_comments)
summary(model_reactions)
