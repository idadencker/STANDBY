)
View(sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
View(sentiment_data)
sentiment_data$ID <- as.character(sentiment_data$ID)  # Convert to character before converting to factor
View(sentiment_data)
sentiment_data$ID <- as.factor(sentiment_data$ID)
View(sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
sum(is.na(sentiment_data$ID))
which(is.na(sentiment_data$ID))
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
View(sentiment_data)
sentiment_data$ID <- as.factor(sentiment_data$ID)
View(sentiment_data)
sentiment_data$ID <- as.character(sentiment_data$ID)  # Convert to character before converting to factor
sentiment_data$ID <- as.factor(sentiment_data$ID)
View(sentiment_data)
model_1 <- lmer(intervention ~ compound + (ID|name_abbreviation) +
(1|municipality), REML=T, data=sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
n_distinct(sentiment_data$name_abbreviation)
#test
model <- lmer(pos_score_roberta ~ roberta_label + (1 | municipality), data=sentiment_data)
model
#
model <- lmer(intervention ~ compound + (1|municipality/name_abbreviation:ID), data = sentiment_data, REML=FALSE)
str(sentiment_data)
#start by facorising data
?str
sapply(sentiment_data, class)
print(sapply(sentiment_data, class))
pprint(sapply(sentiment_data, class))
sapply(sentiment_data, class)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
sapply(sentiment_data, class)
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
#ID = as.character(ID), #make charachter first
#ID = as.factor(ID),
municipality = as.factor(municipality),
name_abbreviation = as.factor(name_abbreviation)
)
sapply(sentiment_data, class)
View(sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
sapply(sentiment_data, class)
sentiment_data$name_abbreviation <- as.character(sentiment_data$name_abbreviation) |> trimws() |> as.factor()
View(sentiment_data)
# Check if all unique values are the same
if(length(unique_values) == 1) {
print("All values in the column are the same.")
} else {
print("There are multiple unique values in the column.")
}
# Check unique values in your character column
unique_values <- unique(sentiment_data$name_abbreviation)
# Check if all unique values are the same
if(length(unique_values) == 1) {
print("All values in the column are the same.")
} else {
print("There are multiple unique values in the column.")
}
sentiment_data$name_abbreviation <- trimws(sentiment_data$name_abbreviation)
sentiment_data$name_abbreviation <- factor(sentiment_data$name_abbreviation, levels = unique_values)
View(sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
View(sentiment_data)
View(sentiment_data)
sentiment_data$name_abbreviation <- gsub("[^[:print:]]", "", sentiment_data$name_abbreviation)
sentiment_data$name_abbreviation <- tolower(sentiment_data$name_abbreviation)
View(sentiment_data)
n_distinct(sentiment_data$name_abbreviation)
sentiment_data$name_abbreviation <- as.factor(sentiment_data$name_abbreviation)
View(sentiment_data)
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
#ID = as.character(ID), #make charachter first
#ID = as.factor(ID),
municipality = as.factor(municipality),
name_abbreviation = as.factor(name_abbreviation)
)
View(sentiment_data)
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
week = as.factor(week),
#ID = as.character(ID), #make charachter first
#ID = as.factor(ID),
municipality = as.factor(municipality),
name_abbreviation = as.factor(name_abbreviation)
)
View(sentiment_data)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
week = as.factor(week),
#ID = as.character(ID), #make charachter first
#ID = as.factor(ID),
municipality = as.factor(municipality),
name_abbreviation = as.factor(name_abbreviation)
)
View(sentiment_data)
sapply(sentiment_data, levels)
nlevels(sentiment_data$name_abbreviation)
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
#can check number of distinct values for a column
n_distinct(sentiment_data$name_abbreviation)
#check class of every column
sapply(sentiment_data, class)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g cant have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
n_post_day,
name_abbreviation = as.factor(name_abbreviation)
)
#check the levels look right
sapply(sentiment_data, levels)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g cant have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
offentlig_privat = as.factor(offentlig_privat),
n_post_day,
name_abbreviation = as.factor(name_abbreviation)
)
#check the levels look right
sapply(sentiment_data, levels)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g cant have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
offentlig_privat = as.factor(offentlig_privat),
roberta_label = as.factor(roberta_label),
name_abbreviation = as.factor(name_abbreviation)
)
#check the levels look right
sapply(sentiment_data, levels)
#can check the number of levels
nlevels(sentiment_data$name_abbreviation)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, lme4)
#load in data
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
#can check number of distinct values for a column
n_distinct(sentiment_data$name_abbreviation)
# preprocessing the data
#check class of every column
sapply(sentiment_data, class)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g we can't have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
offentlig_privat = as.factor(offentlig_privat),
roberta_label = as.factor(roberta_label),
name_abbreviation = as.factor(name_abbreviation)
)
#should ID be level??
#check the levels look right
sapply(sentiment_data, levels)
#can check the number of levels for a factor column
nlevels(sentiment_data$name_abbreviation)
#test lme4 is working
model <- lmer(pos_score_roberta ~ roberta_label + (1 | municipality), data=sentiment_data)
model
plot(pos_score_roberta ~ neg_score_roberta, data = sentiment_data, main = "pos_score_roberta ~ neg_score_roberta")
#simple model
simple_model <- glmer(intervention ~ compound + (1| municipality), data = sentiment_data, family = binomial  )
summary(simple_model)
#simple model 2
simple_model_2 <- glmer(intervention ~ compound + (1| name_abbreviation), data = sentiment_data, family = binomial)
#log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by municipality
summary(simple_model_2)
#First: check level of the outcome variable
levels(sentiment_data$intervention)
#log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by municipality
summary(simple_model)
![alt text here](/Users/idahelenedencker/Desktop/image)
![alt text here](/Users/idahelenedencker/Desktop/image)
library(ggplot2)
# Assuming 'reduced' is your dataframe
# Plotting positive scores
p1 <- ggplot(reduced, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
library(ggplot2)
# Assuming 'reduced' is your dataframe
# Plotting positive scores
p1 <- ggplot(sentiment_data, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
# Plotting neutral scores
p2 <- ggplot(sentiment_data, aes(x = intervention, y = neu_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "black") +
labs(title = "Neutral") +
theme_minimal()
# Plotting negative scores
p3 <- ggplot(sentiment_data, aes(x = intervention, y = neg_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "salmon", color = "black") +
labs(title = "Negative") +
theme_minimal()
# Plotting compound scores
p4 <- ggplot(sentiment_data, aes(x = intervention, y = compound_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgrey", color = "black") +
labs(title = "Compound") +
theme_minimal()
# Combining plots
plot_grid(p1, p2, p3, p4, ncol = 1, align = "v")
library(gridExtra)
library(ggplot2)
library(gridExtra)
# Assuming 'reduced' is your dataframe
# Plotting positive scores
p1 <- ggplot(sentiment_data, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
# Plotting neutral scores
p2 <- ggplot(sentiment_data, aes(x = intervention, y = neu_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "black") +
labs(title = "Neutral") +
theme_minimal()
# Plotting negative scores
p3 <- ggplot(sentiment_data, aes(x = intervention, y = neg_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "salmon", color = "black") +
labs(title = "Negative") +
theme_minimal()
# Plotting compound scores
p4 <- ggplot(sentiment_data, aes(x = intervention, y = compound_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgrey", color = "black") +
labs(title = "Compound") +
theme_minimal()
# Combining plots
plot_grid(p1, p2, p3, p4, ncol = 1, align = "v")
# Combining plots
grid.arrange(p1, p2, p3, p4, ncol = 1)
p4
# Combining plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
#simple model 2
simple_model_2 <- glmer(intervention ~ compound + (1| ID), data = sentiment_data, family = binomial)
#log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by politician
summary(simple_model_2)
#log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by municipality
summary(simple_model)
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound,family=binomial(link='logit'),data=sentiment_data)
summary(no_mixed_model)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, lme4)
pacman::p_load(tidyverse, lme4)
#load in data
sentiment_data <- read_csv('/Users/idahelenedencker/Desktop/STANDBY/vaders_roberta_bert.csv')
#can check number of distinct values for a column
n_distinct(sentiment_data$name_abbreviation)
#check class of every column
sapply(sentiment_data, class)
#factorize data
# data that cant be 'integer' numbers and have levels are transformed, e.g we can't have 7,3 weeks or 1,2 municipality == transformed
sentiment_data <- sentiment_data %>%
mutate(
intervention = as.factor(intervention),
main_post = as.factor(main_post),
week = as.factor(week),
subcomment = as.factor(subcomment),
municipality = as.factor(municipality),
offentlig_privat = as.factor(offentlig_privat),
roberta_label = as.factor(roberta_label),
name_abbreviation = as.factor(name_abbreviation)
)
#check the levels look right
sapply(sentiment_data, levels)
#can check the number of levels for a factor column
nlevels(sentiment_data$name_abbreviation)
library(ggplot2)
library(gridExtra)
# Plotting positive scores
p1 <- ggplot(sentiment_data, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
# Plotting neutral scores
p2 <- ggplot(sentiment_data, aes(x = intervention, y = neu_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "black") +
labs(title = "Neutral") +
theme_minimal()
# Plotting negative scores
p3 <- ggplot(sentiment_data, aes(x = intervention, y = neg_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "salmon", color = "black") +
labs(title = "Negative") +
theme_minimal()
# Plotting compound scores
p4 <- ggplot(sentiment_data, aes(x = intervention, y = compound_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgrey", color = "black") +
labs(title = "Compound") +
theme_minimal()
# Combining plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
#looking here we see that when the intervention is yes the comments are generally more negative (lower pos score + higher neg score + lower compound score). This is good to know when starting to model the effect of intervention. So looking at this, we expect that an intervention (intervention==yes) will entail a more negative sentiment in comments compared to no intervention (intercention == no)
library(ggplot2)
library(gridExtra)
# Plotting positive scores
p1 <- ggplot(sentiment_data, aes(x = intervention, y = pos_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "skyblue", color = "black") +
labs(title = "Positive") +
theme_minimal()
# Plotting neutral scores
p2 <- ggplot(sentiment_data, aes(x = intervention, y = neu_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "black") +
labs(title = "Neutral") +
theme_minimal()
# Plotting negative scores
p3 <- ggplot(sentiment_data, aes(x = intervention, y = neg_score_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "salmon", color = "black") +
labs(title = "Negative") +
theme_minimal()
# Plotting compound scores
p4 <- ggplot(sentiment_data, aes(x = intervention, y = compound_roberta)) +
geom_bar(stat = "summary", fun = "mean", fill = "lightgrey", color = "black") +
labs(title = "Compound") +
theme_minimal()
# Combining plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
#looking here we see that when the intervention is yes the comments are generally more negative (lower pos score + higher neg score + lower compound score). This is good to know when starting to model the effect of intervention. So looking at this, we expect that an intervention (intervention==yes) will entail a more negative sentiment in comments compared to no intervention (intercention == no)
#test lme4 is working
model <- lmer(pos_score_roberta ~ roberta_label + (1 | municipality), data=sentiment_data)
model
summary(model)
#simple plotting
plot(pos_score_roberta ~ neg_score_roberta, data = sentiment_data, main = "pos_score_roberta ~ neg_score_roberta")
#First: check level of the outcome variable
levels(sentiment_data$intervention)
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound,family=binomial(link='logit'),data=sentiment_data)
View(sentiment_data)
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound,family=binomial(link='logit'),data=sentiment_data)
summary(no_mixed_model)
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound_roberta,family=binomial(link='logit'),data=sentiment_data)
#simple model
# in logistic regression coefficients are a on log-oods scale = positive means increase in possibility
simple_model <- glmer(intervention ~ compound_roberta + (1| municipality), data = sentiment_data, family = binomial)
#log odds of intervention is predicted by compound score (fixed effect) allowing the model to vary by municipality
summary(simple_model)
#Below are the commands to run an empty model, that is, a model containing no predictors,
# and calculate the intraclass correlation coefficient (ICC; the degree of homogeneity of the outcome within clusters).
empty_model <- glmer(intervention ~ ( 1 | name_abbreviation), data=sentiment_data, family = "binomial")
#Below are the commands to run an empty model, that is, a model containing no predictors,
# and calculate the intraclass correlation coefficient (ICC; the degree of homogeneity of the outcome within clusters).
empty_model <- glmer(intervention ~ ( 1 | name_abbreviation), data=sentiment_data, family = "binomial")
summary(empty_model)
icc <- empty_model@theta[1]^2/ (empty_model@theta[1]^2 + (3.14159^2/3))
icc <- empty_model@theta[1]^2/ (empty_model@theta[1]^2 + (3.14159^2/3))
icc
var_components <- getVarCov(empty_model)
library(lme4)
var_components <- getVarCov(empty_model)
library(nlme)
var_components <- getVarCov(empty_model)
VarCorr(empty_model)
library(psychometric)
pacman::p_load(psychometric)
ICC1.lme(intervention, intervention, sentiment_data)
#Below are the commands to run an empty model, that is, a model containing no predictors,
# and calculate the intraclass correlation coefficient (ICC; the degree of homogeneity of the outcome within clusters).
empty_model <- glmer(intervention ~ ( 1 | name_abbreviation), data=sentiment_data, family = "binomial")
#Below are the commands to run an empty model, that is, a model containing no predictors,
# and calculate the intraclass correlation coefficient (ICC; the degree of homogeneity of the outcome within clusters).
empty_model <- glmer(intervention ~ ( 1 | name_abbreviation), data=sentiment_data, family = "binomial")
summary(empty_model)
ICC1.lme(intervention, name_abbreviation, sentiment_data)
VarCorr(empty_model)
ICC1.lme(intervention, name_abbreviation, sentiment_data)
colSums(is.na(sentiment_data))
ICC1.lme(intervention, name_abbreviation, sentiment_data)
empty_model@theta[1]
summary(empty_model)
icc
#no mixed effects model
no_mixed_model <- glm(intervention ~ compound_roberta,family=binomial(link='logit'),data=sentiment_data)
summary(no_mixed_model)
#can check number of distinct values for a column
n_distinct(sentiment_data$IS)
#can check number of distinct values for a column
n_distinct(sentiment_data$ID)
#Below are the commands to run an empty model, that is, a model containing no predictors,
# and calculate the intraclass correlation coefficient (ICC; the degree of homogeneity of the outcome within clusters).
empty_model <- glmer(intervention ~ ( 1 | ID), data=sentiment_data, family = "binomial")
summary(empty_model)
## 2-LEVEL MODEL (Comments nested in ID)
two_level_model <- glmer(intervention ~ compound_roberta + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model)
## 3-LEVEL MODEL (comments nested in ID nested in politicians)
three_level_model <- glmer(intervention ~ compound_roberta + (1| ID/name_abbreviation), data = sentiment_data, family = binomial)
summary(three_level_model)
## 4-LEVEL MODEL (comments nested in ID nested in politicians nested in municipality)
four_level_model <- glmer(intervention ~ compound_roberta + (1| ID/name_abbreviation/muncipality), data = sentiment_data, family = binomial)
## 4-LEVEL MODEL (comments nested in ID nested in politicians nested in municipality)
four_level_model <- glmer(intervention ~ compound_roberta + (1| ID/name_abbreviation/municipality), data = sentiment_data, family = binomial)
summary(four_level_model)
#a model with separate random intercepts for each grouping variable without explicitly specifying the nesting. This is assuming that the grouping variables are independent of each other.
no_hier_model <- glmer(intervention ~ compound_roberta + (1| ID) + (1| name_abbreviation) + (1| municipality), data = sentiment_data, family = binomial)
summary(no_hier_model)
## 2-LEVEL MODEL (Comments nested in ID):
two_level_model <- glmer(intervention ~ compound_roberta + (1| ID), data = sentiment_data, family = binomial)
## 2-LEVEL MODEL (Comments nested in ID):
two_level_model <- glmer(intervention ~ compound_roberta + (1| ID), data = sentiment_data, family = binomial)
summary(two_level_model)
summary(two_level_model)
summary(no_mixed_model)
df_performance <- rbind(
performance::model_performance(empty_model, metrics= "common"),
performance::model_performance(no_mixed_model, metrics= "common"),
performance::model_performance(two_level_model, metrics= "common"),
performance::model_performance(three_level_model, metrics= "common"),
performance::model_performance(four_level_model, metrics= "common"),
performance::model_performance(no_hier_model, metrics= "common")) %>%
data.frame() %>%
rownames_to_column("models")
library(performance)
pacman::p_load(performance)
pacman::p_load(performance)
df_performance <- rbind(
performance::model_performance(empty_model, metrics= "common"),
performance::model_performance(no_mixed_model, metrics= "common"),
performance::model_performance(two_level_model, metrics= "common"),
performance::model_performance(three_level_model, metrics= "common"),
performance::model_performance(four_level_model, metrics= "common"),
performance::model_performance(no_hier_model, metrics= "common")) %>%
data.frame() %>%
rownames_to_column("models")
df_performance <- rbind(
performance::model_performance(empty_model, metrics= "common"),
#performance::model_performance(no_mixed_model, metrics= "common"),
performance::model_performance(two_level_model, metrics= "common"),
performance::model_performance(three_level_model, metrics= "common"),
performance::model_performance(four_level_model, metrics= "common"),
performance::model_performance(no_hier_model, metrics= "common")) %>%
data.frame() %>%
rownames_to_column("models")
df_performance <- rbind(
#performance::model_performance(empty_model, metrics= "common"),
#performance::model_performance(no_mixed_model, metrics= "common"),
performance::model_performance(two_level_model, metrics= "common"),
performance::model_performance(three_level_model, metrics= "common"),
performance::model_performance(four_level_model, metrics= "common"),
performance::model_performance(no_hier_model, metrics= "common")) %>%
data.frame() %>%
rownames_to_column("models")
#compare the different models like this:
f4 <- performance::model_performance(empty_model, metrics= "common")
View(f4)
f2 <- performance::model_performance(no_mixed_model, metrics= "common")
View(f2)
f3 <- performance::model_performance(two_level_model, metrics= "common")
f4 <- performance::model_performance(three_level_model, metrics= "common")
View(f4)
f5 <- performance::model_performance(four_level_model, metrics= "common")
f6 <- performance::model_performance(no_hier_model, metrics= "common")
f1 <- performance::model_performance(empty_model, metrics= "common")
f2 <- performance::model_performance(no_mixed_model, metrics= "common")
f3 <- performance::model_performance(two_level_model, metrics= "common")
f4 <- performance::model_performance(three_level_model, metrics= "common")
f5 <- performance::model_performance(four_level_model, metrics= "common")
f6 <- performance::model_performance(no_hier_model, metrics= "common")
f1
f2
print("model 1:")f1
print("model 1:")
print("model 1:")
f1
print("empty_model:")
f1
print("no_mixed_model:")
f2
print("two_level_model:")
f3
print("three_level_model:")
f4
print("four_level_model:")
f5
print("no_hier_model:")
f6
summary(no_hier_model)
